\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}

\geometry{a4paper, margin=1in}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,
    upquote=true,
    extendedchars=true
}

\lstset{style=mystyle}

\title{Backend Software Manual}
\author{324827328, 213713522}
\date{}

\begin{document}

\ifdefined\maindoc
\else
  \maketitle
  \tableofcontents
  \newpage
\fi

\section{Introduction}
The backend for the Movie Database was designed with a focus on performance, reliability, and modularity. We adopted a layered architecture to ensure clear separation of concerns: Routers manage HTTP requests, the Repository layer abstracts database interactions, and the application logic connects these components.

\section{Technologies}
We selected a technology stack that prioritizes development efficiency and system stability.

\subsection{Python}
Python serves as the core language for our development. Its concise syntax allows for efficient expression of complex logic. Whether for data migration scripts or defining API endpoints, Python's readability facilitates maintenance and debugging.

\subsection{FastAPI}
FastAPI was chosen for its high performance and modern features, representing a significant improvement over older frameworks.
\begin{enumerate}
    \item \textbf{Performance}: Utilizing modern Python features like \texttt{async/await}, it offers high throughput comparable to lower-level languages.
    \item \textbf{Automatic Documentation}: The automatic generation of Swagger UI documentation facilitates efficient endpoint testing and verification.
    \item \textbf{Data Validation}: Integration with Pydantic ensures rigorous data validation, rejecting invalid requests automatically.
\end{enumerate}

\subsection{Uvicorn}
Uvicorn serves as the ASGI server for the application, enabling the handling of concurrent connections efficiently without blocking.

\subsection{MySQL Connector}
The \texttt{mysql-connector} library provides robust database connectivity. We encapsulated this within a \texttt{Repository} class to manage connection pooling and execution automatically.

\subsection{Pandas}
Pandas was utilized to efficienty import and process large CSV datasets. It allowed for in-memory data cleaning and transformation before migration to the SQL database.

\subsection{Python-Dotenv}
\texttt{python-dotenv} is used to manage environment variables, ensuring that sensitive credentials are kept secure in a local \texttt{.env} file and excluding them from version control.

\section{Core Infrastructure}

\subsection{The Entry Point (\texttt{main.py})}
This file initializes the application. We configured the CORS middleware to allow requests from the Angular frontend, which operates on a different port (4200).

\begin{lstlisting}[language=Python, caption={CORS Configuration}]
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:4200"], # Allow our Angular app
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
\end{lstlisting}

\subsection{The Data Access Layer}
To maintain a clean codebase, we implemented a generic `Repository` class in `app/repository.py`. This class wraps database interactions, managing connection pools and executing queries safely.

\begin{lstlisting}[language=Python, caption={Database execution wrapper}]
@staticmethod
def fetch_all(query: str, params: Optional[tuple] = None) -> List[Dict[str, Any]]:
    conn = get_db_connection()
    # We use dictionary=True so we get real column names, not just tuples
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute(query, params or ())
        return cursor.fetchall()
    finally:
        # Always clean up, even if the query fails
        cursor.close()
        conn.close()
\end{lstlisting}

\section{How It Works: API Modules}

\subsection{Movies Router (\texttt{routers/movies.py})}
A key challenge here was the "N+1 Problem". A naive approach would query the `movies` table once, and then run additional queries for each movie to fetch related data.

We addressed this by using "Bulk Fetching". We query the movies to obtain IDs, then execute optimized queries to fetch all related genres, cast, and crew data in bulk, mapping them in memory.

\begin{lstlisting}[language=Python, caption={Aggregation in memory}]
# 1. Get the movie IDs
movie_ids = [m['id'] for m in movies]

# 2. Get all related data in bulk
genres_data = Repository.fetch_all(f"SELECT ... WHERE movie_id IN ({placeholders})", movie_ids)

# 3. Map them in memory
genres_by_movie = defaultdict(list)
for g in genres_data:
    genres_by_movie[g['movie_id']].append(g['genre_name'])

# 4. Attach to movie objects
for movie in movies:
    movie['genres'] = genres_by_movie[movie['id']]
\end{lstlisting}

\subsubsection{The Rating Transaction}
We perform ratings transactionally to ensure data consistency. We insert the rating and update the movie's average score within the same operation.

\begin{lstlisting}[language=Python, caption={Transactional update}]
# Step 1: Insert the user's rating
Repository.execute("INSERT INTO ratings ... ON DUPLICATE KEY UPDATE...", (...))

# Step 2: Update the movie's cached average immediately
Repository.execute("UPDATE movies SET vote_average = %s ...", (...))
\end{lstlisting}

\subsection{Analytics Router (\texttt{routers/analytics.py})}
These endpoints perform complex aggregation queries. For example, to identify "Flops", we calculate the difference between budget and revenue at the database level.

\begin{lstlisting}[language=Python, caption={Analytics query example}]
@router.get("/analytics/flops")
def flops():
    # We let the database engine do the subtraction and sorting
    query = """
        SELECT title, budget, revenue, (budget - revenue) as loss
        FROM movies
        WHERE budget > 1000000 AND revenue < budget AND revenue > 0
        ORDER BY loss DESC
        LIMIT 10
    """
    return Repository.fetch_all(query)
\end{lstlisting}

\end{document}
